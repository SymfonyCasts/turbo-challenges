preview:
  question: |
    Hey! I've prepared this template for a shiny new Pong page!
    
    ```twig
    {% extends 'base.html.twig' %}
    
    {% block title%}Play Pong in the Browser for Free!{% endblock %}
    
    {% block metas %}{% endblock %}
    
    {% block body %}
        <div id="pong_game_app"></div>
    {% endblock %}
    ```
    
    I even added a `block metas` so that I can add the proper `head` tag to avoid this... but,
    I can't seem to remember exactly how this is!
    
    What is the actual `meta` tag that we need to add to stop turbo previews?
  explanation: |
    You can also set this meta to contain the value `no-cache` which means that it won't generate
    any previews at all (not even for the back button!)

    Other metas that we can leverage with turbo are:
    
    ```twig
    <meta name="turbo-visit-control" content="reload">
    ```
    
    To enforce a complete reload every time turbo visits this page. Check the Turbo Drive reference
    for more information on these!
  features:
    multiple_choice:
      choices:
        a: |
          ```twig
          <meta name="turbo-cache" content="no-preview">
          ```
        b: |
          ```twig
          <meta name="cache-control" content="no-preview">
          ```
        c: |
          ```twig
          <meta name="turbo-cache-control" content="no-preview">
          ```
        d: |
          ```twig
          <meta name="cache" content="no-preview">
          ```
      correct: c

modal_preview:
  question: |
    What happens when Turbo creates a preview of a page?
  explanation: |
    This is important because you need to make sure your page functionality is preserve
    between page views.
    
    In general, the best way to add JavaScript functionality with Turbo Drive is its best
    friend: Stimulus! But there *are* workarounds we can do to keep our existing JavaScript
    working.
  features:
    multiple_choice:
      choices:
        a: |
          At the moment right before leaving the page, Turbo clones the DOM using `cloneNode`,
          which does *not* include event listeners added from JavaScript.
        b: |
          At page load, Turbo clones the DOM using a "deep clone" algorithm, but
          since JavaScring hasn't executed yet, we don't get any listeners adde dy it.
        c: |
          At the moment right before leaving the page, Turbo clones the DOm using a "deep
          clone" algorithm, but removes any event listeners added by JavaScript because
          it relies on Stimulus to add them back.
        d: |
          At page load, and after all JavaScript has been parsed and executed, Turbo clones
          the DOM using a "deep clone" algorithm, but it removes any event listeners added by
          JavaScript because ir relies on Stimulus to add them back.
      correct: a
  
modal_preview_2:
  question: |
    In my web page, I decided to create my own modal. It's just a `div` element
    that I set to `display: block` whenever I want to show it. Not a big deal!
    
    ```twig
    <div id="my_great_modal" style="display: none">
        <h1>Welcome our Pizza Section!</h1>
    
        <p>You need to be a pizza lover before you proceed!</p>
    
        <button
            class="btn btn-primary"
            onclick="javascript:document.getElementById('my_great_modal').style.display='none';"
        >
            Proceed
        </button>
    </div>
    ```
    
    I then use JavaScript to discretely show this popup under certain circumstances (i.e. when
    I detect that a customer might not love pizza!).
    
    But, when the user leaves the page and then goes back, Turbo is showing this modal
    *even* when the user might have proven otherwise that he is indeed a Pizzal lover!
    I don't want that!
    
    How can I hide this modal every time Turbo shows my page preview?
  explanation: |
    Leveraging the turbo event `turbo:before-cache` is the best solution for things like
    these, because you can clean up and prepare your snapshow before turbo takes it so that
    you ensure that you will always see the right state!
    
    Other seemingly useful events, like `turbo:load` might look useful, but they will
    only fire after the page has finished loading, which means that the preview event
    already took place!
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          document.addEventListener('turbo:before-visit', (event) => {
              document.getElementById('my_great_modal').display = 'none';
          });
          ```
        b: |
          ```javascript
          document.addEventListener('turbo:before-cache', (event) => {
              document.getElementById('my_great_modal').display = 'none';
          });
          ```
        c: |
          ```javascript
          document.addEventListener('turbo:before-fetch-request', (event) => {
              document.getElementById('my_great_modal').display = 'none';
          });
          ```
        d: |
          ```javascript
          document.addEventListener('turbo:load', (event) => {
              document.getElementById('my_great_modal').display = 'none';
          });
          ```
      correct: b

cleaned_preview:
  question: |
    In our video, we show how closing a bootstrap dialog before exiting a page,
    so that we can have a cleaned preview, doesn't quite work. When we came
    back to the page, we saw a greyed invalidation div covering it!
    
    Fixing this required some more hacking on our part in order to have it working
    properly.
    
    Why did we get this weird behavior?
  explanation: |
    The `turbo:before-cache` event is synchronous, which means that what you do in that
    event handler will happen instantly. If in that event you call some animation
    (like the bootstrap `close` function), then the animation won't finish executing,
    preventing any callbacks after the animation from cleaning up the page.
    
    It's important to know this for any third party code that we use, so that when
    preparing a snapshop on the `before-cache` event goes smoothly!
    
    > Alternatively, you can disable cache on certain pages if the clean up
    > process seems too complicated
  features:
    multiple_choice:
      choices:
        a: |
          This happened because bootstrap has a bug where some times calling `close`
          on a modal doesn't close it properly.
        b: |
          This happened because Turbo has a bug where some times our code inside a
          `turbo:before-cache` event doesn't execute properly.
        c: |
          This happenbed because we called `close` on our dialog and forgot to make the
          `turbo:before-cache` callback asynchronous.
        d: |
          This happened because we called `close` on our dialog right inside
          `turbo:before-cache` and the closing animation didn't have time to
          finish before the cache was saved.
      correct: d

js_widget:
  question: |
    In this video, we've added a Weather Widget sanippet into our page and saw how it
    only work the first time our page loaded. When we clicked on subsecuent pages, it
    stopped working!
    
    Why is this so?
  explanation: |
    In our video, the snipped of code is executed every time we load a page because it's
    in our `body` element! But in it there's a check before adding the `script` to our
    `head`. This `script` is only added if it's not already present. This is why the
    `script` tag was only added once, and therefore, only executed once between our page
    views!
    
    > When we forced our snippet to add the `script` tag without any check, it effectively
    > added a new copy of itself into our `head` *every* single time we change the page.
    > This worked, but now we have a new problem: Our `head` is growing forever!
  features:
    multiple_choice:
      choices:
        a: |
          Because the `script` tag added by our snippet of code is only added once, hence
          it only executes once.
        b: |
          Because the snippet of code added by us is only executed once, hence it only
          adds the `script` tag once
        c: |
          Because Turbo recognizes similar scripts between page views and avoids re-executing
          them.
        d: |
          The widget snipped worked as expected. It did not stop working after subsecuent
          page views.
      correct: a

analytics:
  question: |
    When does the event `turbo:before-render` fire?
  explanation: |
    This is very usefull because you can access the contents of the new `body` element
    that is about to replace the old one, so that you can tweak it and modify it
    before any JavaScript is executed!
    
    > You can access the "about to be added" `body` elements with `event.detail.newBody`!
    
    > Related is the `turbo:render` event, which fires *after* the entire rendering operation
    > has completed.
  features:
    multiple_choice:
      choices:
        a: |
          It fires every time turbo has to render a page, but before its new contents have
          arrived via Ajax.
        b: |
          It fires once per session, before Turbo initializes its JavaScript engine.
        c: |
          It fires every time that turbo has received a new page via Ajax and before it
          replaces the `body` element with the new `body` contents.
        d: |
          It fires every time that turbo has received a new page via Ajax, after it
          replaces the `body` element but *before* executing any JavaScript in it
      correct: c

analytics_2:
  question: |
    At the end of our video, we talk about analytics and show an example of how you can
    execute code *once* (and only once) on every page load (including the first page load!)
    
    What is this event and why others don't work?
  explanation: |
    `turbo:laod` is very usefull if we need to execute some code on a "per view" basis. It will
    execute on every page view and will *not* repeat itself if a page has a preview. *Just* what
    we need to get our analytics code working!
  features:
    multiple_choice:
      choices:
        a: |
          The event to use is `turbo:load`. `turbo:before-render` and `turbo:render` do NOT execute
          on the first load. The *also* execute twice if page has a preview to show first!
        b: |
          The event to use is `turbo:load`. `turbo:before-render` could also work, but it does not
          execute on the first page load.
        c: |
          The event to use is `turbo:render`. `turbo:load` only executes on the first page load but
          doesn't execute later. `turbo:before-render` can execute twice if a page has a preview.
        d: |
          The event to use is `turbo:before-render`. `turbo:render` can execute twice if a page
          has a preview, but *not* `turbo:before-render`. `turbo:load` only executes on the first
          page load but doesn't execute later.
      correct: a
