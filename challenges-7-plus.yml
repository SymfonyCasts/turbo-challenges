preview:
  question: |
    Hey! I've prepared this template for a shiny new Pong page!
    
    ```twig
    {% extends 'base.html.twig' %}
    
    {% block title%}Play Pong in the Browser for Free!{% endblock %}
    
    {% block metas %}{% endblock %}
    
    {% block body %}
        <div id="pong_game_app"></div>
    {% endblock %}
    ```
  
    But now... I want to avoid showing a "preview" if the user navigates back to this page.
    I've added a `block metas` so that I an add the proper tag to the `<head>` element to avoid
    the preview... but I can't seem to remember exactly how this is!
    
    What is the actual `meta` tag that we need to add to stop turbo previews?
  explanation: |
    You can also set this meta to contain the value `no-cache` which means that it won't generate
    any snapshot cache at all (not even for the back button!)

    Other metas that we can leverage with turbo are:
    
    ```html
    <meta name="turbo-visit-control" content="reload">
    ```
    
    This enforces a full page reload every time turbo visits this page. Check the Turbo Drive reference
    for more information on these!
  features:
    multiple_choice:
      choices:
        a: |
          ```html
          <meta name="turbo-cache" content="no-preview">
          ```
        b: |
          ```html
          <meta name="cache-control" content="no-preview">
          ```
        c: |
          ```html
          <meta name="turbo-cache-control" content="no-preview">
          ```
        d: |
          ```html
          <meta name="cache" content="no-preview">
          ```
      correct: c

modal_preview:
  question: |
    What happens when Turbo creates a preview of a page?
  explanation: |
    This is important because you need to make sure your page functionality is preserved
    between page views.
    
    In general, the best way to add JavaScript functionality with Turbo Drive is its best
    friend: Stimulus! But there *are* workarounds we can do to keep our existing JavaScript
    working.
  features:
    multiple_choice:
      choices:
        a: |
          At the moment right before leaving the page, Turbo clones the DOM using `cloneNode`,
          which does *not* include event listeners added from JavaScript.
        b: |
          At page load, Turbo clones the DOM using a "deep clone" algorithm, but
          since JavaScript hasn't executed yet, no listeners are included in the preview.
        c: |
          At the moment right before leaving the page, Turbo clones the DOM using a "deep
          clone" algorithm, but removes any event listeners added by JavaScript because
          it relies on Stimulus to add them back.
        d: |
          At page load, and after all JavaScript has been parsed and executed, Turbo clones
          the DOM using a "deep clone" algorithm. It then removes any event listeners added by
          JavaScript because it relies on Stimulus to add them back.
      correct: a
  
modal_preview_2:
  question: |
    In my web page, I decided to create my own modal. It's just a `<div>` element
    that I set to `display: block` whenever I want to show it. Not a big deal!
    
    ```html
    <div id="my_great_modal" style="display: none">
        <h1>Welcome to our Pizza Section!</h1>
    
        <p>You need to be a pizza lover before you proceed!</p>
    
        <button
            class="btn btn-primary"
            onclick="javascript:document.getElementById('my_great_modal').style.display='none';"
        >
            Proceed
        </button>
    </div>
    ```
    
    I then use JavaScript to discretely show this popup under certain circumstances (i.e. when
    I detect that a customer might not love pizza!).
  
    But, when the user leaves the page when the modal is opened and then hits the browser's
    back button, Turbo is showing this modal for a brief period of time while the preview is
    showing. I don't want that!
    
    How can I hide this modal every time Turbo shows my page preview?
  explanation: |
    Leveraging the turbo event `turbo:before-cache` is the best solution for things like
    these, because you can clean up and prepare your snapshot before turbo takes it so that
    you ensure that you will always see the right state!
    
    Other events, like `turbo:load` might look useful, but they will
    only fire after the page has finished loading, which means that the preview event
    already took place!
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          document.addEventListener('turbo:before-visit', (event) => {
              document.getElementById('my_great_modal').display = 'none';
          });
          ```
        b: |
          ```javascript
          document.addEventListener('turbo:before-cache', (event) => {
              document.getElementById('my_great_modal').display = 'none';
          });
          ```
        c: |
          ```javascript
          document.addEventListener('turbo:before-fetch-request', (event) => {
              document.getElementById('my_great_modal').display = 'none';
          });
          ```
        d: |
          ```javascript
          document.addEventListener('turbo:load', (event) => {
              document.getElementById('my_great_modal').display = 'none';
          });
          ```
      correct: b

cleaned_preview:
  question: |
  
    In our video, we show how closing a bootstrap dialog before exiting a page,
    so that we can have a cleaned preview, doesn't quite work. When we came
    back to the page, we saw a greyed invalidation div covering it!
  
    Fixing this required some more hacking to get it working properly.
    
    Why did we get this weird behavior?
  explanation: |
    The `turbo:before-cache` event is synchronous, which means that what you do in that
    event handler will happen instantly. If, in that event, you call some animation
    (like the bootstrap `close` function), then the animation won't finish executing.
  
    This can cause two potential problems. First, the snapshot will be taken before the element
    that is animating (e.g. the modal closing) is finished animating. And second, as in this case,
    Bootstrap is "listening" for the animation to finish so that it can do other clean up, like
    removing the overlay. But because the element was removed from the page, the animation never
    "finishes" and the cleanup never happens. Weird, eh?
    
    > Alternatively, you can disable cache on certain pages if the clean up
    > process seems too complicated
    
    > Also, starting on Turbo Drive v7.0.0-beta.8, you can add `data-turbo-cache="false"` to
    > *any* DOM element individually so that they get removed before the page gets cached
    > without you doing anything else!
  features:
    multiple_choice:
      choices:
        a: |
          This happened because bootstrap has a bug where calling `close`
          on a modal sometimes doesn't close it properly.
        b: |
          This happened because Turbo has a bug where sometimes our code inside a
          `turbo:before-cache` event doesn't execute quickly enough.
        c: |
          This happened because we called `close` on our dialog and forgot to make the
          `turbo:before-cache` callback asynchronous.
        d: |
          This happened because we called `close` on our dialog right inside
          `turbo:before-cache` and the closing animation didn't have time to
          finish before the cache was saved.
      correct: d

js_widget:
  question: |
    In this video, we've added a weather widget snippet to our page and saw how it
    only works the first time our page loaded. When we clicked on subsequent pages, it
    stopped working!
    
    Why?
  explanation: |
    In our video, the snippet of code is executed every time we load a page because it's
    in our `<body>` element! But inside the snippet itself, there's a check before adding
    the `<script>` to our `<head>`: the `<script>` is only added if it's not already present.
    This is why the `<script>` tag was only added once, and therefore, only executed one
    time no matter how many pages we visit with Turbo.
    
    > When we forced our snippet to add the `<script>` tag without any check, it effectively
    > added a new copy of itself into our `<head>` *every* single time we change the page.
    > This worked, but now we have a new problem: our `<head>` is growing forever!
  features:
    multiple_choice:
      choices:
        a: |
          Because the `<script>` tag added by our snippet of code is only added once, hence
          it only executes once.
        b: |
          Because the snippet of code added by us to the `<bode>` element is only executed once,
          hence it only adds the `<script>` tag to our `<head>` once.
        c: |
          Because Turbo recognizes similar scripts between page views and avoids re-executing
          them.
        d: |
          The widget snippet worked as expected. It did not stop working after subsequent
          page views: we even verified that the `a` tag was present!
      correct: a

analytics:
  question: |
    When does the `turbo:before-render` event fire?
  explanation: |
    This is useful because you can access the contents of the new `<body>` element
    that is about to replace the old one, so that you can tweak it and modify it
    before any JavaScript is executed!
    
    > You can access the "about to be added" `<body>` element with `event.detail.newBody`!
    
    > Related is the `turbo:render` event, which fires *after* the entire rendering operation
    > has completed.
  features:
    multiple_choice:
      choices:
        a: |
          It fires every time turbo has to render a page, but before its new contents have
          arrived via Ajax.
        b: |
          It fires once per session, before Turbo initializes its JavaScript engine.
        c: |
          It fires every time that turbo has received a new page via Ajax and before it
          replaces the `<body>` element with the new `<body>` contents.
        d: |
          It fires every time that turbo has received a new page via Ajax, after it
          replaces the `<body>` element but *before* executing any JavaScript in it.
      correct: c

analytics_2:
  question: |
    At the end of our video, we talk about analytics and show an example of how you can
    execute code *once* (and only once) on every page load (including the first page load!)
    
    What event acomplishes this? And what is the *best* explanation for why other events won't work?
  explanation: |
    `turbo:laod` is very usefull if we need to execute some code on a "per view" basis. It will
    execute on every page view and will *not* repeat itself if a page has a preview. *Just* what
    we need to get our analytics code working!
  features:
    multiple_choice:
      choices:
        a: |
          The event to use is `turbo:load`. `turbo:before-render` and `turbo:render` do NOT execute
          on the first load. They *also* execute twice if a page has a preview to show first!
        b: |
          The event to use is `turbo:load`. `turbo:before-render` could also work, but it does not
          execute on the first page load.
        c: |
          The event to use is `turbo:render`. `turbo:load` only executes on the first page load but
          doesn't execute later. `turbo:before-render` can execute twice if a page has a preview.
        d: |
          The event to use is `turbo:before-render`. `turbo:render` can execute twice if a page
          has a preview, but *not* `turbo:before-render`. `turbo:load` only executes on the first
          page load but doesn't execute later.
      correct: a
