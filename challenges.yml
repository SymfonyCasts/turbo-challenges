how_drive_works:
  question: |
    How is Turbo activated when using the `symfony/ux-turbo` package?
  explanation: |
    Symfony adds a dummy stimulus controller to its controller list. This controller simply
    imports `@hotwired/turbo` (which activates Turbo Drive!) and exposes `Turbo` as a global
    variable. Fun fact: since beta 6, when you import `@hotwired/turbo`, that automatically
    exposes `Turbo` as a global variable (so, the dummy controller doesn't really need to do
    it anymore).
  features:
    multiple_choice:
      choices:
        a: |
          When you install `symfony/ux-turbo`, it adds a dummy stimulus controller to
          `controllers.json` file that imports `@hotwired/turbo`.
        b: |
          Turbo is automatically added to your codebase when you use webpack encore
          and have `@hotwired/turbo` installed via `packacke.json`.
        c: |
          It doesn't work out of the box. You need to import Turbo on all of your files or in
          `assets/bootstrap.js`. This way, you can selectively choose which parts of your website
          use Turbo and which don't.
      correct: a

how_drive_works_2:
  question: |
    Once you install `symfony/ux-turbo`, it automatically starts working throughout your
    website. But, how exactly does it work and what does it do?
  explanation: |
    Turbo Drive intercepts actions like clicks and form submits and loads them with an Ajax call.
    It will then save snapshots of these pages so that when you click the back or forward buttons
    in your browser, the pages will load instantly. If a page takes a long time to load, it will
    even show a progress bar on top of the page that you can customize!
  features:
    multiple_choice:
      choices:
        a: |
          It downloads and installs a browser extension that processes all requests in the
          background before clearing the page.
        b: |
          It loads JavaScript that intercepts events like clicks and form submits and
          makes an Ajax request to load them in the background.
        c: |
          It works in the backend by leveraging web sockets, which make all pages load
          faster.
      correct: b

how_drive_works_3:
  question: |
    When Turbo Drive loads a new page, what exactly happens behind the scenes?
  explanation: |
    Turbo will merge the tags present in the `<head>` tag in a smart way.
    
    It will remove anything in `<head>` other than JavaScripts and CSS tags. After removing
    all non-JS and non-CSS tags from the old page, it will then inject anything that is left,
    such as the `title` element and meta data elements from the old page to the new.
    Lastly, it will add those `<script>` and `<css>` tags that aren't present in the current page.
  features:
    multiple_choice:
      choices:
        a: |
          Turbo replaces the old page with the new page loaded through
          Ajax and executes all `<script>` tags again.
        b: |
          Turbo merges all scripts, meta-data and even the `<title>` element present in
          the `<head>` tag, then replaces the `<body>` with new content.
        c: |
          Turbo replaces the `<body>` with the new content but leaves the `<head>` tag intact,
          except for the `<title>` element, which is replaced with the new title.
        d: |
          Turbo merges the new `<head>` tag by adding new `<script>` and `<link>` tags but replacing any
          other tags with those from the new page. It then replaces the `<body>`.
      correct: d
      
javascript:
  question: |
    What is the biggest way in which JavaScript works differently on Turbo-enabled websites?
  explanation: |
    As Turbo only loads JavaScript files once (and executes them once) per "session" (i.e. full page refresh), you
    need to make sure any initialization code that needs to run on every "page load" is executed
    properly! New scripts that are *added* to the `head`, however, do get parsed!
    
    > If you put JavaScript into the `body` of a page, it will execute normally on every
    > page load!
  features:
    multiple_choice:
      choices:
        a: |
          There are no significant differences between a normal website and a Turbo Drive powered
          site. That's what makes Turbo so great: you can use it on any site without major changes.
        b: |
          The difference is that, when Turbo Drive loads a new page, every JavaScript script
          is parsed and executed again to ensure that the new page has been reinitialized
          properly. This includes old scripts that don't get removed!
        c: |
          The difference is that, when Turbo Drive loads a new page, `<script>` tags that were
          present in the previous page, don't get parsed and executed again, as you might
          expect with a normal page load.
        d: |
          The difference is that, when Turbo Drive loads a new page, new script tags found in the `<body>` tag are
          parsed but not executed. You need to move these to the `<head>` tag for them to be parsed.
      correct: c

javascript_2:
  question: |
    What is one reason why it is not recommended to have JavaScript inside the `body` tag on a Turbo Drive
    powered website?
  explanation: |
    When Turbo Drive switches to a page that was previously visited, its cache feature,
    which makes the page appear instantly, will cause any JavaScript in the `<body>` to be
    executed. When the actual page finishes loading, turbo will replace the cached page
    with the new one, causing another execution of its JavaScript, thus potentially causing
    issues.
  
    Also, executing the same JavaScript code on every page is wasteful! When you put JavaScript
    in the `<head>` tag, it's only parsed and executed *one* time, which means there is less
    work to do each time Turbo Drive navigates to a new page.
    
    The best way to use JavaScript in a Turbo Drive powered website is Stimulus!
  features:
    multiple_choice:
      choices:
        a: |
          Having JavaScript in the `body` tag is not a recommended practice and thus,
          should be avoided.
        b: |
          Because the Turbo cache can cause this JavaScript to be executed twice on a page
          load, leading to potential issues.
        c: |
          There are no problems with having JavaScript in your `body` tag, although it is
          not a recommended practice!
        d: |
          Because the JavaScript included in a `body` tag will *not* be executed by Turbo Drive
          when the page loads!
      correct: b

disabling:
  question: |
    Given this very basic template:
    
    ```twig
    <html>
        <head>
            <title>My Template</title>
            {% block javascripts %}{% endblock %}
            {% block stylesheets %}{% endblock %}
        </head>
        <body>
            {% block body %}{% endblock %}
        </body>
    </html>
    ```
    
    How can we disable turbo on this page?
  explanation: |
    If you set the property `data-turbo="false"` in a `<body>` tag, it will effectively disable
    Turbo for that entire page!
    
    > You can also disable or enable (with `data-turbo="true") specific links within a page
    > or entire page sections!
  features:
    multiple_choice:
      choices:
        a: |
          ```html
          <html data-turbo="false">
              <head>
                  <title>My Template</title>
                  {% block javascripts %}{% endblock %}
                  {% block stylesheets %}{% endblock %}
              </head>
              <body>
                  {% block body %}{% endblock %}
              </body>
          </html>
          ```
        b: |
          ```diff
          <html>
              <head>
                  <title>My Template</title>
                  <meta data-turbo="false">
                  {% block javascripts %}{% endblock %}
                  {% block stylesheets %}{% endblock %}
              </head>
              <body>
                  {% block body %}{% endblock %}
              </body>
          </html>
          ```
        c: |
          ```diff
          <html>
              <head>
                  <title>My Template</title>
                  <meta data-turbo="false">
                  {% block javascripts %}{% endblock %}
                  {% block stylesheets %}{% endblock %}
              </head>
              <body data-turbo="false">
                  {% block body %}{% endblock %}
              </body>
          </html>
          ```
        d: |
          Once you install and set up turbo (i.e. include Turbo in your main
          JavaScript entry), you cannot disable it, except on a link-by-link basis.
      correct: c
      
forms:
  question: |
    In this video, we fixed our forms by making them respond with a 422 status code
    when they fail. Which of the following explains why we do this?
  explanation: |
    A 422 status when a form has errors is a better way of handling a form failure. It
    also tells Turbo that there has been an error and needs to re-render the page.
  
    Previously, when we returned a 200 status code, it made Turbo think that our form
    did submit successfully. But, when a form submits successfully, we should redirect.
    This... confused Turbo, which thought that our form did submit successfully...
    but then we did not redirect.
  features:
    multiple_choice:
      choices:
        a: |
          We do this to avoid an error by Turbo where it says that "form submits should
          redirect to another location".
        b: |
          We do this to better conform to HTTP standards, since our code was incomplete
          in this regard.
        c: |
          We do this to show a nice new feature of synfomy regarding forms, where it can
          handle different status codes on different situations.
        d: |
          All of the above.
      correct: d

preview:
  question: |
    Hey! I've prepared this template for a shiny new Pong page!
    
    ```twig
    {% extends 'base.html.twig' %}
    
    {% block title%}Play Pong in the Browser for Free!{% endblock %}
    
    {% block metas %}{% endblock %}
    
    {% block body %}
        <div id="pong_game_app"></div>
    {% endblock %}
    ```
    
    But now... I want to avoid showing a "preview" if the user navigates back to this page.
    I've added a `block metas` so that I an add the proper tag to the `<head>` element to avoid
    the preview... but I can't seem to remember exactly how this is!
    
    What is the actual `meta` tag that we need to add to stop turbo previews?
  explanation: |
    You can also set this meta to contain the value `no-cache` which means that it won't generate
    any snapshot cache at all (not even for the back button!)
    
    Other metas that we can leverage with turbo are:
    
    ```html
    <meta name="turbo-visit-control" content="reload">
    ```
    
    This enforces a full page reload every time turbo visits this page. Check the Turbo Drive reference
    for more information on these!
  features:
    multiple_choice:
      choices:
        a: |
          ```html
          <meta name="turbo-cache" content="no-preview">
          ```
        b: |
          ```html
          <meta name="cache-control" content="no-preview">
          ```
        c: |
          ```html
          <meta name="turbo-cache-control" content="no-preview">
          ```
        d: |
          ```html
          <meta name="cache" content="no-preview">
          ```
      correct: c

modal_preview:
  question: |
    What happens when Turbo creates a preview of a page?
  explanation: |
    This is important because you need to make sure your page functionality is preserved
    between page views.
    
    In general, the best way to add JavaScript functionality with Turbo Drive is its best
    friend: Stimulus! But there *are* workarounds we can do to keep our existing JavaScript
    working.
  features:
    multiple_choice:
      choices:
        a: |
          At the moment right before leaving the page, Turbo clones the DOM using `cloneNode`,
          which does *not* include event listeners added from JavaScript.
        b: |
          At page load, Turbo clones the DOM using a "deep clone" algorithm, but
          since JavaScript hasn't executed yet, no listeners are included in the preview.
        c: |
          At the moment right before leaving the page, Turbo clones the DOM using a "deep
          clone" algorithm, but removes any event listeners added by JavaScript because
          it relies on Stimulus to add them back.
        d: |
          At page load, and after all JavaScript has been parsed and executed, Turbo clones
          the DOM using a "deep clone" algorithm. It then removes any event listeners added by
          JavaScript because it relies on Stimulus to add them back.
      correct: a

modal_preview_2:
  question: |
    In my web page, I decided to create my own modal. It's just a `<div>` element
    that I set to `display: block` whenever I want to show it. Not a big deal!
    
    ```html
    <div id="my_great_modal" style="display: none">
        <h1>Welcome to our Pizza Section!</h1>
    
        <p>You need to be a pizza lover before you proceed!</p>
    
        <button
            class="btn btn-primary"
            onclick="javascript:document.getElementById('my_great_modal').style.display='none';"
        >
            Proceed
        </button>
    </div>
    ```
    
    I then use JavaScript to discretely show this popup under certain circumstances (i.e. when
    I detect that a customer might not love pizza!).
    
    But, when the user leaves the page when the modal is opened and then hits the browser's
    back button, Turbo is showing this modal for a brief period of time while the preview is
    showing. I don't want that!
    
    How can I hide this modal every time Turbo shows my page preview?
  explanation: |
    Leveraging the turbo event `turbo:before-cache` is the best solution for things like
    these, because you can clean up and prepare your snapshot before turbo takes it so that
    you ensure that you will always see the right state!
    
    Other events, like `turbo:load` might look useful, but they will
    only fire after the page has finished loading, which means that the preview event
    already took place!
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          document.addEventListener('turbo:before-visit', (event) => {
              document.getElementById('my_great_modal').display = 'none';
          });
          ```
        b: |
          ```javascript
          document.addEventListener('turbo:before-cache', (event) => {
              document.getElementById('my_great_modal').display = 'none';
          });
          ```
        c: |
          ```javascript
          document.addEventListener('turbo:before-fetch-request', (event) => {
              document.getElementById('my_great_modal').display = 'none';
          });
          ```
        d: |
          ```javascript
          document.addEventListener('turbo:load', (event) => {
              document.getElementById('my_great_modal').display = 'none';
          });
          ```
      correct: b

cleaned_preview:
  question: |
    
    In our video, we show how closing a bootstrap dialog before exiting a page,
    so that we can have a cleaned preview, doesn't quite work. When we came
    back to the page, we saw a greyed invalidation div covering it!
    
    Fixing this required some more hacking to get it working properly.
    
    Why did we get this weird behavior?
  explanation: |
    The `turbo:before-cache` event is synchronous, which means that what you do in that
    event handler will happen instantly. If, in that event, you call some animation
    (like the bootstrap `close` function), then the animation won't finish executing.
    
    This can cause two potential problems. First, the snapshot will be taken before the element
    that is animating (e.g. the modal closing) is finished animating. And second, as in this case,
    Bootstrap is "listening" for the animation to finish so that it can do other clean up, like
    removing the overlay. But because the element was removed from the page, the animation never
    "finishes" and the cleanup never happens. Weird, eh?
    
    > Alternatively, you can disable cache on certain pages if the clean up
    > process seems too complicated
    
    > Also, starting on Turbo Drive v7.0.0-beta.8, you can add `data-turbo-cache="false"` to
    > *any* DOM element individually so that they get removed before the page gets cached
    > without you doing anything else!
  features:
    multiple_choice:
      choices:
        a: |
          This happened because bootstrap has a bug where calling `close`
          on a modal sometimes doesn't close it properly.
        b: |
          This happened because Turbo has a bug where sometimes our code inside a
          `turbo:before-cache` event doesn't execute quickly enough.
        c: |
          This happened because we called `close` on our dialog and forgot to make the
          `turbo:before-cache` callback asynchronous.
        d: |
          This happened because we called `close` on our dialog right inside
          `turbo:before-cache` and the closing animation didn't have time to
          finish before the cache was saved.
      correct: d

js_widget:
  question: |
    In this video, we've added a weather widget snippet to our page and saw how it
    only works the first time our page loaded. When we clicked on subsequent pages, it
    stopped working!
    
    Why?
  explanation: |
    In our video, the snippet of code is executed every time we load a page because it's
    in our `<body>` element! But inside the snippet itself, there's a check before adding
    the `<script>` to our `<head>`: the `<script>` is only added if it's not already present.
    This is why the `<script>` tag was only added once, and therefore, only executed one
    time no matter how many pages we visit with Turbo.
    
    > When we forced our snippet to add the `<script>` tag without any check, it effectively
    > added a new copy of itself into our `<head>` *every* single time we change the page.
    > This worked, but now we have a new problem: our `<head>` is growing forever!
  features:
    multiple_choice:
      choices:
        a: |
          Because the `<script>` tag that our snippet of code adds to `<head>` is only added once,
          due to a check made by the code itself, and only executes once.
        b: |
          Because the `<script>` tag added by our snippet of code to `<head>` is added multiple
          times but only executed once since there is no full page load when we are navigating
          using Turbo Drive.
        c: |
          Because Turbo recognizes similar scripts between page views and avoids re-executing
          them between page views.
        d: |
          The widget snippet worked as expected. It did not stop working after subsequent
          page views: we even verified that the `a` tag was present!
      correct: a

analytics:
  question: |
    When does the `turbo:before-render` event fire?
  explanation: |
    This is useful because you can access the contents of the new `<body>` element
    that is about to replace the old one, so that you can tweak it and modify it
    before any JavaScript is executed! Notice that when a page has a preview of it,
    this event will fire twice! Once on the preview, and once when the full page load
    has finished after the Ajax request!
    
    > You can access the "about to be added" `<body>` element with `event.detail.newBody`!
    
    > Related is the `turbo:render` event, which fires *after* the entire rendering operation
    > has completed.
  features:
    multiple_choice:
      choices:
        a: |
          It fires every time turbo has to render a page, but before its new contents have
          arrived via Ajax.
        b: |
          It fires once per session, before Turbo initializes its JavaScript engine.
        c: |
          It fires every time that turbo has to render a page, including new Ajax requests
          and previews, and before it replaces the `<body>` element with the new `<body>`
          contents.
        d: |
          It fires every time that turbo has received a new page via Ajax, after it
          replaces the `<body>` element but *before* executing any JavaScript in it.
      correct: c

analytics_2:
  question: |
    At the end of our video, we talk about analytics and show an example of how you can
    execute code *once* (and only once) on every page load (including the first page load!)
    
    What event acomplishes this? And what is the *best* explanation for why other events won't work?
  explanation: |
    `turbo:laod` is very usefull if we need to execute some code on a "per view" basis. It will
    execute on every page view and will *not* repeat itself if a page has a preview. *Just* what
    we need to get our analytics code working!
  features:
    multiple_choice:
      choices:
        a: |
          The event to use is `turbo:load`. `turbo:before-render` and `turbo:render` do NOT execute
          on the first load. They *also* execute twice if a page has a preview to show first!
        b: |
          The event to use is `turbo:load`. `turbo:before-render` could also work, but it does not
          execute on the first page load.
        c: |
          The event to use is `turbo:render`. `turbo:load` only executes on the first page load but
          doesn't execute later. `turbo:before-render` can execute twice if a page has a preview.
        d: |
          The event to use is `turbo:before-render`. `turbo:render` can execute twice if a page
          has a preview, but *not* `turbo:before-render`. `turbo:load` only executes on the first
          page load but doesn't execute later.
      correct: a
