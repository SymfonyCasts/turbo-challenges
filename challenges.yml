how_drive_works:
  question: |
    How does Turbo work inside a Symfony-ux project?
  explanation: |
    Symfony adds a dummy stimulus controller to its controller list. All this controller
    does, is import the Turbo functionality into its JavaScript and expose the Turbo
    variable in `window`!
  features:
    multiple_choice:
      choices:
        a: |
          When you install `symfony/ux-turbo`, it adds a dummy stimulus controller to
          `controllers.json`, it takes care of adding Turbo functionality into your site.
        b: |
          Turbo is automatically added to your codebase when you use webpack encore
          on a symfony-ux project.
        c: |
          It doesn't work out of the box. You need to import Turbo on all of your files. This
          way, you can selectively choose which parts of your website use Turbo and which don't.
      correct: a

how_drive_works_2:
  question: |
    Once you install `symfony/ux-turbo`, it automatically starts working throughout your
    website. But, how exactly does it work and what does it do?
  explanation: |
    Turbo will intercept actions like clicks and form submits and load them with an Ajax call.
    It will then save snapshots of these pages so that when you click the back or forward buttons
    in your browser, the pages will load instantly. If a page takes a long time to load, it will
    even show a progress bar on top of the page that you can customize!
  features:
    multiple_choice:
      choices:
        a: |
          It downloads and install a browser extension that processes all request in the
          background before clearing the page.
        b: |
          It loads JavaScript that intercepts events like clicks and form submits and
          makes an Ajax request to load them in the background.
        c: |
          It works in the backend by leveraging web sockets, which make all pages load
          faster.
      correct: b

how_drive_works_3:
  question: |
    When Turbo Drive loads a new page, what exactly happens behind the scenes?
  explanation: |
    Turbo will merge the tags present in the `head` tag in a smart way.
    
    It will remove anything in `head` other than JavaScripts and CSS tags. It will then inject
    any new such elements, such as the `title` element and meta data elements. Lastly, it will
    add those `script` and `css` tags that aren't present in the current page.
  features:
    multiple_choice:
      choices:
        a: |
          Turbo replaces the old page with the new page loaded through
          Ajax and executes all `<script>` tags again.
        b: |
          Turbo merges all scripts, meta-data and even title element present in
          the `head` tag, then replaces the `body` with new content.
        c: |
          Turbo replaces the `body` with the new content but leaves the `head` tag intact,
          except for the `<title>` element, which is replaced with the new title.
        d: |
          Turbo will merge the new `head` tag with the old one in a smart way, only adding
          new entries and scripts to it. It then replaces the `body`.
      correct: d
      
javascript:
  question: |
    What is the biggest way in which JavaScript works differently on Turbo-enabled websites?
  explanation: |
    As Turbo only loads JavaScript files once (and executes them once) per "session" (i.e. full page refresh), you
    need to make sure any initialization code that needs to run once the DOM loads, is executed
    properly! New scripts that are *added* to the `head`, however, do get parsed!
    
    > If you put JavaScript into the `body` of a page, it will execute normally on every
    > page load!
  features:
    multiple_choice:
      choices:
        a: |
          There are no significant differences between a normal website and a Turbo Drive powered
          site. That's what makes Turbo so great: you can use it on any site without major changes.
          Website. JavaScript always behave the same way in a Browser.
        b: |
          The difference is that, when Turbo Drive loads a new page, every JavaScript script
          is parsed and executed again to ensure that the new page has been reinitialized
          properly. This includes old scripts that don't get removed!
        c: |
          The difference is that, when Turbo Drive loads a new page, script tags that were
          present in the previous page, don't get parsed and executed again, as you might
          expect with a normal page load.
        d: |
          The difference is that, when Turbo Drive loads a new page, new script tags found in the `<body>` tag are
          parsed but not executed. You need to move these to the `<head>` tag for them to be parsed.
      correct: c

javascript_2:
  question: |
    Why is it not recommended to have JavaScript inside the `body` tag on a Turbo Drive
    powered Website?
  explanation: |
    When Turbo Drive switches to a page that was previously visited, its cache feature,
    which makes the page appear instantly, will cause any JavaScript in the `body` to be
    executed. When the actual page finishes loading, turbo will replace the cached page
    with the new one, causing another execution of its JavaScript, thus potentially causing
    issues.
    
    The best way to use JavaScript in a Turbo Drive powered Website is Stimulus!
  features:
    multiple_choice:
      choices:
        a: |
          Having JavaScript in the `body` tag is not a recommended practice and thus,
          should be avoided.
        b: |
          Because the Turbo cache can cause this JavaScript to be executed twice on a page
          load, leading to potential issues.
        c: |
          There are no problems with having JavaScript in your `body` tag, although it is
          not a recommended practice!
        d: |
          Because the JavaScript included in a `body` tag will *not* be executed by Turbo Drive
          when the page loads!
      correct: b

disabling:
  question: |
    Given this very basic template (please ignore the missing tags and attributes :p ):
    
    ```twig
    <html>
        <head>
            <title>My Template</title>
            {% block javascripts %}{% endblock %}
            {% block styles %}{% endblock %}
        </head>
        <body>
            {% block body %}{% endblock %}
        </body>
    </html>
    ```
    
    How can we disable turbo on this page?
  explanation: |
    If you set the property `data-turbo="false"` in a `body` tag, it will effectively disable
    Turbo for that entire page!
    
    > You can also disable or enable (with `data-turbo="true") specific links within a page
    > or entire page sections!
  features:
    multiple_choice:
      choices:
        a: |
          ```twig
          <html data-turbo="false">
              <head>
                  <title>My Template</title>
                  {% block javascripts %}{% endblock %}
                  {% block styles %}{% endblock %}
              </head>
              <body>
                  {% block body %}{% endblock %}
              </body>
          </html>
          ```
        b: |
          ```twig
          <html>
              <head>
                  <title>My Template</title>
                  <meta data-turbo="false">
                  {% block javascripts %}{% endblock %}
                  {% block styles %}{% endblock %}
              </head>
              <body>
                  {% block body %}{% endblock %}
              </body>
          </html>
          ```
        c: |
          ```twig
          <html>
              <head>
                  <title>My Template</title>
                  {% block javascripts %}{% endblock %}
                  {% block styles %}{% endblock %}
              </head>
              <body data-turbo="false">
                  {% block body %}{% endblock %}
              </body>
          </html>
          ```
        d: |
          Once you install and set up turbo (i.e. include Turbo in your main
          JavaScript entry, you cannot disable it.
      correct: c
      
forms:
  question: |
    In this video, we fixed our forms by making them respond with a 422 status code
    when they fail. Why did we do this?
  explanation: |
    A 422 status when a form has errors is a better way of handling a form failure. It
    also tells Turbo that there has been an error and needs to re-render the page.
  features:
    multiple_choice:
      choices:
        a: |
          We do this to avoid an error by Turbo where it says that "form submits should
          redirect to another location". By sending a different status other than 200,
          we are basically telling Turbo to reload that template.
        b: |
          We do this to better conform to HTTP standards, since our code was incomplete
          in this regard
        c: |
          We do this to hint to Turbo that the form submit was *not* successful (since a 200
          status code looks like it *was* successful).
          handle different status codes on different situations.
      correct: a
