asset-tracking:
  question: |
    I just came from our company meeting and I have big news! We have just released a
    new version of our main CSS file!
    
    But I'm getting complaints from users who are unable to see those changes! Oh no!
    
    How can I make Turbo Drive show the new version of my site to all my users without
    waiting for them to do a full refresh (i.e. by closing their browsers and come back
    the next day)?
  explanation: |
    One of the few instances in which we can say that a full reload is *needed* is when
    our frontend code changes (JavaScript or CSS)!
    
    By adding file versioning to our system, we can make sure that new files are downloaded once
    they change. But this alone is not enough! Webpack prevents similar named files with
    different hashes from running! And besides, if they did run, we would be duplicating
    them on our `<head>` element: the old *and* new CSS/JavaScript files would be loaded on the same page!
    
    By leveraging the `data-turbo-track="reload"` attribute on our `<script>` and `<link>`
    tags, we can make Turbo Drive force a reload of the page if the collection of files
    in the `<head>` element ever changes! This combination of techniques is our best
    friend!
  features:
    multiple_choice:
      choices:
        a: |
          By modifying `config/packages/webpack_encore.yaml` and adding
  
          ```yml
          'data-turbo-track': reload
          ```

          To both `link_attributes` and `script_attributes`.
        b: |
          By making sure you enable versioning in Webpack Encore:
          
          ```javascript
          .enableVersioning(Encore.isProduction())
          ```
          
          By modifying `config/packages/webpack_encore.yaml` and adding
          
          ```yml
          'data-turbo-track': reload
          ```
          
          To both `link_attributes` and `script_attributes`.
        c: |
          By modifying `config/packages/webpack_encore.yaml` and adding
  
          ```yml
          'data-turbo-track': refresh
          ```

          To `link_attributes`.
        d: |
          By making sure you enable versioning in Webpack Encore:
  
          ```javascript
          .enableVersioning(Encore.isProduction())
          ```

          And by modifying `config/packages/webpack_encore.yaml` and adding

          ```yml
          'data-turbo-webpack': track-versioning
          ```

          To both `link_attributes` and `script_attributes`.
      correct: b

manual_visit:
  question: |
    On our site, there is one section that is very special: we expose the secrets to
    creating the world's most perfect pizza. But not all users are ready for this
    earth-shattering information. And so, I've decided to open a big dialog on the
    front page of that section...
    of users can enter, so I've decided to pop up a big dialog in the front page
    of that section so that users can *leave* if they don't feel up to it!
    
    Here's how it looks!
    
    ```html
    <div id="my_great_modal" style="display: none">
        <h1>Welcome to our Pizza Section!</h1>

        <p>Proceed only if you are ready for pizza to change your life!</p>

        <button
            class="btn btn-primary"
            onclick="javascript:document.getElementById('my_great_modal').style.display='none';"
        >
            Proceed
        </button>
    </div>
    ```
    
    This works as expected, but I'm a bit nervous about leaving too much time
    for our users to decide. They should be quick! So I've added a timeout on
    the main JavaScript of the page to force users *away* after a certain
    amount of time.
    
    ```javascript
    window.setTimeout(() => {
        window.location.href = '/';
    }, 10000);
    ```
    
    How can we use Turbo Drive (instead of just `window.location.href=`)
    to perform a page visit without doing a full refresh?
  explanation: |
    By using the syntax `import * as Turbo from '@hotwired/turbo'` you import *all*
    public functions from the library into an object called `Turbo`. This enables
    you to use some Turbo Drive specific actions in your scripts, like `Turbo.visit()`.
    
    > You can also use destructuring to import only the functions you need. In
    > this case, that would be: `import { visit } from '@hotwired/turbo'`.
    
    > Turbo is also set automatically as a global variable once you import it anywhere in your
    > page, so you can also use Turbo from inline scripts... though you should try avoiding those, of course ðŸ˜‰. 
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          import Turbo from '@hotwired/turbo';

          window.setTimeout(() => {
              Turbo.visit('/');
          }, 10000);
          ```
        b: |
          ```javascript
          import * as Turbo from '@hotwired/turbo`;

          window.setTimeout(() => {
              Turbo.location.href = '/';
          }, 10000);
          ```
        c: |
          ```javascript
          import * as Turbo from '@hotwired/turbo`;

          window.setTimeout(() => {
              Turbo.visit = '/';
          }, 10000);
          ```
        d: |
          ```javascript
          import * as Turbo from '@hotwired/turbo`;
          
          window.setTimeout(() => {
              Turbo.visit('/');
          }, 10000);
          ```
      correct: d
      
transitions:
  question: |
    I just came back from a meeting with our designer, and she has an *amazing* concept
    for a new transition that we need to add to our page loads between clicks! It looks like
    this in the CSS main file:
    
    ```css
    body {
        background-color: #fff
        transition: background-color 0.2s;
    }
    
    body.turbo-loading {
        background-color: #f00;
    }
    ```
  
    I think this is going to look *awesome* (and won't render too many of our viewers blind)!
    
    So, how can we implement these transitions using Turbo Drive event listeners?
  explanation: |
    `turbo:visit` will trigger immediately after a user clicks on a link to another page.
    It will take care of transitioning our background color to `red`.
    
    Once the new page renders, in order to gracefully fade back into white -as opposed to
    an instant change- we use two more events:
    
    `turbo:before-render` re-adds this class to the newly added `<body>` element so that it *starts*
    red.
    
    Finally, once the rendering finishes, `turbo:render` removes it on the browser's next frame,
    so that the browser can play the transition to the white color.
    
    > Notice that `turbo:load` won't work, because it doesn't track each visit precisely as
    > the user clicks on the link or otherwise interacts with the page to cause a page load.
    
    Cool!
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          document.addEventListener('turbo:visit', () => {
              document.body.classList.add('turbo-loading');
          });
          ```
        b: |
          ```javascript
          document.addEventListener('turbo:visit', () => {
              document.body.classList.add('turbo-loading');
          });
          
          document.addEventListener('turbo:before-render', (event) => {
              event.detail.newBody.classList.add('turbo-loading');
          });
          
          document.addEventListener('turbo:render', () => {
              requestAnimationFrame(() => {
                 document.body.classList.remove('turbo-loading');
              });
          });
          ```
        c: |
          ```javascript
          document.addEventListener('turbo:visit', () => {
              document.body.classList.add('turbo-loading');
          });

          document.addEventListener('turbo:before-render', (event) => {
              event.detail.newBody.classList.add('turbo-loading');
          });
          ```
        d: |
          ```javascript
          document.addEventListener('turbo:load', () => {
              document.body.classList.add('turbo-loading');
          });

          document.addEventListener('turbo:before-render', (event) => {
              event.detail.newBody.classList.add('turbo-loading');
          });

          document.addEventListener('turbo:render', () => {
              requestAnimationFrame(() => {
                 document.body.classList.remove('turbo-loading');
              });
          });
          ```
      correct: b
  
transitions_2:
  question: |
    Why is it hard in Turbo to implement page load transitions in versions 7.0.0 beta?
    
    > Notice that starting with version 7.0.0-rc.1 the "Pausable rendering" PR has been
    > merged, making it easier to implement page transitions between clicks!
  explanation: |
    The fact that we cannot pause a render operation in Turbo before 7.0.0-rc.1 means that
    our transition, if we make one, will always take the time it takes for the Ajax call
    to finish. This makes it hard for us to perform complex transitions when we can't
    *pause* the render until our animation properly finishes.
  features:
    multiple_chopice:
      a: |
        Because there are no good event handlers to use when transitioning pages for
        this particular purpose.
      b: |
        Actually, you *can* easily implement page transitions between clicks in 7.0.0 beta.
      c: |
        Because when a page finishes loading, Turbo replaces the `<body>` element
        immediately, leaving no time for a transition.
      d: |
        Because there are other libraries that can achieve this.
    correct: c

transition_finish:
  question: |
    Our lead designer is *annoyed*! When our page went live, we've discovered that some
    of our transitions didn't work as expected! Instead of fading to red and then back
    to white, they faded from red to white twice!
    
    You can imagine how disappointed our clients were when they didn't get to properly experience
    all those shades of pink.
    
    Our designer asks us why this happened. What should we tell them?
  explanation: |
    Our `turbo:before-render` and `turbo:render` events are flawed! They happen when a real
    page, as well as a preview page, renders!
    
    This is the cause of the quirkiness that we've experienced. When the user travels to
    a page that has a preview, our `turbo-loading` class is added and removed twice,
    causing the double fade-in from red to white!
  features:
    multiple_choice:
      choices:
        a: |
          This happens when the user visits a page that has been previewed before,
          because the Turbo events `turbo:before-render` and `turbo:render` fire
          both for real pages and preview pages alike.
        b: |
          This happens when the user visits a new page that has no preview, because
          in that case, when a preview is being made, the Turbo events `turbo:before-render`
          and `turbo:render` are fired twice.
        c: |
          This happens when the user visits a page by clicking the back or forward
          button in the browser, because the Turbo event `turbo:visit` fires twice
          in such instances.
        d: |
          This happens when the user clicks on a button to submit a form, because
          the Turbo event `turbo:visit` fires twice in such instances.
      correct: a

transition_finish_2:
  question: |
    In order to fix this page transition issue (and save our jobs), we need to find
    a way to identify when a `turbo:before-render` or a `turbo:render` event come
    from a preview or a real page.
    
    We need to make sure our previews have the `turbo-loading` class in their `<body>`
    elements so that the red doesn't flash twice!
    
    How can we do this?
  explanation: |
    Turbo adds a `data-turbo-preview` attribute to the `<html>` element whenever a preview is rendered. We
    can use this to identify whether we're dealing with a preview or a real page in JavaScript.
    cases in which we need to identify wheather we're dealing with a preview or a real
    page in Turbo.
  features:
    multiple_choice:
      choices:
        a: |
          You can do this by performing this check using JavaScript:
  
          ```javascript
          document.body.hasAttribute('data-turbo-preview');
          ```
        b: |
          You can do this by performing this check using JavaScript:
  
          ```javascript
          document.querySelector('body').hasAttribute('data-turbo-preview');
          ```
        c: |
          You can do this by performing this check using JavaScript:
          
          ```javascript
          document.documentElement.hasAttribute('data-turbo-preview');
          ```
        d: |
          There is no way of differenciating between a preview and a real page in
          Turbo.
      correct: c

native_prefetch:
  question: |
    Imagine our website has a *very* important landing page - the route to it is
    `app_pizzas`. We want to "prefetch" this from *every* page so that it's
    always ready to be loaded instantly if the user wants to go there.
    
    Assuming we have a `{% block metas %}{% endblock %}` that we can override, what
    is the native way in which we can do this?
  explanation: |
    `<link rel="prefetch">` is a useful tool that you can leverage with Turbo Drive
    when you need to make certain pages readily available to the user.
    
    In our example, we infer that we are adding this prefetch link on every page. Make
    sure you have this in mind, because if you add a prefetch link in a *specific* page,
    this won't stay in the `<head>` element for other pages!
  features:
    multiple_choice:
      a: |
        ```twig
        <link rel="prefetch" src="{{ path('app_pizzas') }}">
        ```
      b: |
        ```twig
        <link rel="prefetch" href="{{ path('app_pizzas') }}">
        ```
      c: |
        ```twig
        <a rel="prefetch" href="{{ path('app_pizzas') }}"></a>
        ```
      d: |
        ```twig
        <meta rel="prefetch" href="{{ path('app_pizzas') }}">
        ```
    correct: b

lazy_frame:
  question: |
    What is a Turbo Frame and what does it do?
  explanation: |
    The `<turbo-frame>` HTML element is a special element that allows us
    to make areas of our web pages dynamic.
    
    You can use Turbo Frames if you want navigation to happen inside an
    area of the page, instead of having the whole page refreshed.
    
    Another use is when you want a part of your page to load lazily, once
    the general structure has loaded.
  features:
    multiple_choice:
      choices:
        a: |
          A Turbo Frame is an `<iframe>` element in a page that has extra
          functionality, like loading pages via ajax calls.
        b: |
          Tturbo Frames is a system that allows you to create complex animations
          in our web pages.
        c: |
          A Turbo Frame is an area of our page in which we can load content and
          update it via Ajax calls that return HTML. It behaves similarly to the
          old `<iframe>` system.
        d: |
          A Turbo Frame is an area of our page that has the ability to stay loaded
          while other parts of our page change. It is mainly used as navigation bars.
      correct: c

frames_find_frames:
  question: |
    My website has a terribly complex sidebar! Our project manager asked us to extract
    it to a separate route so that we could load it lazily using Turbo Frames. This
    work is done! Our route has the name `_app_nav`, and the rendered frame has an id of
    `app_nav_frame`.
    
    How could we load this in our main template?
  explanation: |
    It's very important that when a frame is loaded by Turbo, its HTML contains at least
    one `<turbo-frame>` element with an `id` that we can identify!
    
    The rest is *almost* magic!
  features:
    multiple_choice:
      choices:
        a: |
          ```twig
          <turbo-frame src="{{ path('_app_nav') }}"></turbo-frame>
          ```
        b: |
          ```twig
          <turbo-frame id="app_nav_frame"></turbo-frame>
          ```
        c: |
          ```twig
          <turbo-frame id="_app_nav" src="{{ path('app_nav_frame') }}"></turbo-frame>
          ```
        d: |
          ```twig
          <turbo-frame id="app_nav_frame" src="{{ path('_app_nav') }}"></turbo-frame>
          ```
      correct: d

frames_find_frames_2:
  question: |
    When we load a Turbo Frame we need to specify an `id` property both in the frame
    on the page that does the loading, and on the frame in the rendered fragment.
    
    Why is this so?
  explanation: |
    A core feature of Turbo Frames is the ability to get a full page rendered by your
    server but *only* load the part of the page that matches one or several Turbo Frames.
    
    This means that several frames can load *the same* URL and only take the parts that
    belong to that particular frame for updating it.
  features:
    multiple_choice:
      choices:
        a: |
          Because Turbo needs to know if the rendered fragment matches the frame that
          did the request, since URLs can be hacked.
        b: |
          The rendered response can have any id. Turbo just looks at `<turbo-frame>`
          elements within it and will only render that part of the response.
        c: |
          Because Turbo will look at the part of the rendered response
          that exactly matches the `<turbo-frame id="">` pattern and only render that
          part.
      correct: c
